# Тестирование встраиваемых систем STM32 с использованием QEMU эмулятора и Docker

## Рекомендации

Статья будет полезна разработчикам встраиваемых систем, которые хотят автоматизировать процесс тестирования своих проектов. В качестве примера используется библиотека логирования ([GitHub](https://github.com/AleksandrVin/logging_cmsis_rtos2), [Habr](https://habr.com/ru/articles/814745/)), но описанный подход применим к любым проектам на базе STM32.

## Введение

При разработке встраиваемых систем тестирование часто становится узким местом процесса разработки. Основные проблемы включают:

- **Зависимость от железа:** Необходимость иметь физическое устройство для каждого разработчика и CI-сервера
- **Сложность автоматизации:** Подключение реальных устройств к CI-системам требует дополнительного оборудования и настройки
- **Воспроизводимость тестов:** Тесты на реальном оборудовании могут давать различные результаты из-за временных характеристик и состояния устройства

В этой статье рассмотрим подход к решению этих проблем с помощью эмулятора QEMU и контейнеризации через Docker. В качестве примера возьмем библиотеку логирования для STM32, но описанные методы применимы к любым проектам на базе этого микроконтроллера. Особенно это актуально для удаленной разработки.

В описываемом подходе используются открытые инструменты и технологии, что позволяет легко адаптировать под конкретные нужды и использовать в коммерческих проектах.

### Что вы узнаете из статьи

1. [Как настроить среду разработки](#система-сборки-в-docker-и-эмулятор-qemu) с использованием Docker и QEMU
2. [Как подготовить тестовый проект](#тестовый-проект) на базе STM32CubeMX
3. [Как автоматизировать тестирование](#автоматическое-тестирование) STM32 проектов
4. [Как отлаживать приложение](#отладка-с-использованием-gdb-и-vs-code) в эмуляторе

## Система сборки в Docker и эмулятор QEMU

### Почему Docker?

При разработке встраиваемых систем мы часто сталкиваемся с проблемой "у меня работает". Это происходит из-за различий в:

- Версиях компилятора
- Установленных библиотеках
- Настройках окружения

Docker решает эти проблемы, предоставляя изолированную среду с точно определенными версиями всех компонентов.

### Структура Docker-контейнеров

Для создания полноценной среды разработки используется три контейнера:

1. **Контейнер для кросс-компиляции** ([Dockerfile.tests](https://github.com/AleksandrVin/logging_cmsis_rtos2/blob/main/test/Dockerfile.tests))
   - Содержит ARM GCC toolchain, загруженный напрямую с developer.arm.com
   - Обеспечивает доступ к последней версии arm-none-eabi-gcc
   - Включает make и другие инструменты сборки

2. **Контейнер с QEMU** ([Dockerfile.qemu_stm32](https://github.com/AleksandrVin/logging_cmsis_rtos2/blob/main/test/Dockerfile.qemu_stm32))
   - Собирает QEMU из исходного кода [beckus/qemu_stm32](https://github.com/beckus/qemu_stm32)
   - Компиляция QEMU происходит только при первой сборке контейнера
   - Эмулирует периферию микроконтроллера

    > ⚠️ **Важно:** Используемая версия QEMU является устаревшей и поддерживает только старые модели STM32. Существует потребность в обновлении эмулятора для поддержки современных микроконтроллеров STM32. Это может быть интересным проектом для сообщества разработчиков.

3. **Контейнер для запуска тестов** ([Dockerfile.run_tests](https://github.com/AleksandrVin/logging_cmsis_rtos2/blob/main/test/Dockerfile.run_tests))
   - Объединяет результаты работы предыдущих контейнеров
   - Запускает тесты и собирает результаты
   - Генерирует отчеты о тестировании

### QEMU для STM32

QEMU - это мощный эмулятор, который может эмулировать различные архитектуры процессоров. Для работы с STM32 используется специальная версия QEMU, которая добавляет поддержку периферии STM32.

#### Поддерживаемая периферия

На момент написания статьи для STM32F103C8 поддерживается:

- UART
- Таймеры
- GPIO
- Прерывания
- Базовые системные функции

> 💡 **Совет:** Несмотря на ограничения текущей версии QEMU, этот подход к тестированию может быть адаптирован под другие эмуляторы или более новые версии QEMU по мере их появления.

## Тестовый проект

### Генерация проекта в STM32CubeMX

Проект создан с помощью STM32CubeMX, что обеспечивает корректную начальную конфигурацию микроконтроллера и периферии.

![Конфигурация тактирования STM32CubeMX](./stm32cubemx_clocks.png)

Ключевые настройки проекта:

- Тактирование: HSE 8MHz с PLL до 72MHz
- UART1 для вывода логов
- GPIO PC13 для LED индикации
- Системные таймеры для FreeRTOS

![Окно настройки FreeRTOS](./stm32cubemx_rtos.png)
> Конфигурация FreeRTOS с использованием CMSIS-RTOS2 API

При генерации кода важно выбрать правильные параметры:

![Окно настройки проекта](./stm32cubemx_additional_code_gen.png)
> Копирование библиотек в проект. Использование .c и .h файлов для переферии.

![Окно настроек генерации кода](./stm32cubemx_project_gen.png)
> Выбор Makefile в качестве системы сборки для интеграции с Docker. Увеличение размера кучи, т.к. используется динамическая память во FreeRTOS. При тестировании создается 10 потоков.

### Структура проекта

Проект использует стандартную структуру STM32CubeMX, которая находится в директории `tests_stm32`. Скрипты для сборки и тестирования находятся в директории `test`. Тестируемая библиотека находится в директории `lib` и копируется в проект при сборке.

```tree
├── lib
│   ├── logging.c
│   ├── logging.h
│   ├── logging_usb.c
│   └── logging_usb.h
├── LICENSE
├── README.md
└── test
    ├── compose.yaml
    ├── Dockerfile.qemu_stm32
    ├── Dockerfile.run_tests
    ├── Dockerfile.tests
    ├── start_qemu_gdb_mode.sh
    ├── test_in_docker.sh
    ├── test.sh
    ├── tests_stm32
    │   ├── Core
    │   ├── Drivers
    │   ├── logging_cmsis_rtos2
    │   ├── Makefile
    │   ├── Middlewares
    │   ├── startup_stm32f103xb.s
    │   ├── STM32F103C8Tx_FLASH.ld
    │   └── tests_stm32.ioc
    └── verify_output.py
```

При сборке, test.sh копирует библиотеку в тестовый проект и запускает сборку. В Makefile добавлены дополнительные флаги для сборки библиотеки и тестов.

### FreeRTOS интеграция

FreeRTOS настраивается через STM32CubeMX с следующими параметрами:

- Включен DefaultTask
- Динамическое выделение памяти
- Увеличен размер heap для поддержки многопоточного теста где создается 10 дополнительных потоков. При стандартной конфигурации freertos хватит только на динамическое создание 2 потоков.
- Активированы функции трассировки (подробнее в разделе отладки)

Весь пользовательский код FreeRTOS размещается в `freertos.c`:

```c:test/tests_stm32/Core/Src/freertos.c
// Определение основного потока
osThreadId_t defaultTaskHandle;
const osThreadAttr_t defaultTask_attributes = {
  .name = "defaultTask",
  .stack_size = 128 * 4,
  .priority = (osPriority_t) osPriorityNormal,
};

// Точка входа для тестов
void StartDefaultTask(void *argument)
{
  logging_init();
  // Задержка для подключения терминала
  osDelay(1000);
  // Запуск тестов
  logging_test();
  // ...
}
```

Этот поток используется как точка входа для запуска тестов и инициализации библиотеки логирования.

> 💡 **Совет:** STM32CubeMX позволяет легко модифицировать конфигурацию проекта через графический интерфейс с последующей регенерацией кода. Однако, это и в некотором смысле обязавает разработчика всегда изменять конфигурацию через cubemx, дабы не нарушить структуру проекта, что скажется на читаемости кода и возможностях доработки.

## Тестирование библиотеки логирования

Тесты реализованы в [`tests.c`](https://github.com/AleksandrVin/logging_cmsis_rtos2/blob/main/test/tests_stm32/Core/Src/tests.c) и проверяют различные режимы работы библиотеки логирования:

```c:test/tests_stm32/Core/Src/tests.c
void logging_test()
{
    logging_basic_test("basic_test");                  // Базовые тесты
    osDelay(200);                                      // Ожидание вывода логов
    logging_test_pack("pack_of_ten_ten_times");       // Пакетная запись
    osDelay(200);                                      // Ожидание вывода логов
    logging_test_different_levels("different_levels"); // Разные уровни логов
    osDelay(200);                                      // Ожидание вывода логов
    logging_test_fatal("fatal");                      // Фатальные ошибки
    osDelay(200);                                      // Ожидание вывода логов
    logging_interrupt();                              // Логи из прерываний
    osDelay(200);                                      // Ожидание вывода логов
    logging_test_multiple_threads();                  // Многопоточный тест
}
```

> 💡 **Примечание:** Задержки между тестами (`osDelay`) позволяют потоку логирования опустошить буферы и четко разделить вывод разных тестовых сценариев.

### Ключевые тестовые сценарии

1. **Базовое тестирование**

    ```text
    [INFO     ][1s.1]: basic_test_0
    [INFO     ][1s.12]: basic_test_1
    [INFO     ][1s.22]: basic_test_2
    ```

    - Проверка форматирования сообщений
    - Временные метки с миллисекундной точностью
    - Последовательная запись логов

    Библиотека логирования использует тики ядра FreeRTOS для получения времени. Время фиксириуется при вызове функции логирования и хранится в буфере до передачи через интерфейс, те отражает время возникновения события, а не передачи через интерфейс.

2. **Уровни логирования**

    ```text
    [DEBUG_ALL][2s.112]: different_levels_DEBUG_ALL
    [DEBUG_MIN][2s.112]: different_levels_DEBUG_MIN
    [INFO     ][2s.112]: different_levels_INFO
    [WARNING  ][2s.112]: different_levels_WARNING
    [ERROR    ][2s.112]: different_levels_ERR
    ```

3. **Специальные режимы**

    ```text
    # Фатальные ошибки (прямой вывод в UART)
    fatal_0
    fatal_1

    # Логи из прерываний (без буферизации)
    [INFO     ][2s.512]ISR: LOG_ISR_9
    ```

    - `LOG_FATAL` - прямая запись в UART, без буферизации
    - `LOG_ISR` - логирование из прерываний, без использования буфера

    ```c:test/tests_stm32/Core/Src/tests.c
    void logging_interrupt()
    {
        // только последний лог будет напечатан
        for (int i = 0; i < LOGS_AT_ONCE; i++) {
            LOG_ISR(INFO, "LOG_ISR_%d", i);
        }
    }
    ```

    > ⚠️ **Важно про ISR:** В выводе видно только последнее сообщение (`LOG_ISR_9`), и это ожидаемое поведение. В контексте прерывания:
    > - Нельзя использовать блокирующие операции
    > - Буферизация не применяется
    > - Поток логирования имеет более низкий приоритет
    > В результате, пока поток логирования обрабатывает одно сообщение, следующий вызов `LOG_ISR` уже перезаписывает данные. Это компромисс между безопасностью работы в ISR и гарантией доставки всех сообщений.

4. **Многопоточный тест**

    ```c
    void logging_test_multiple_threads()
    {
        for (int i = 0; i < THREADS_AMOUNT; i++) {
            threads[i] = osThreadNew(logging_thread, names[i], NULL);
        }
    }
    ```

    ```text
    [INFO     ][2s.812]: logging_thread_4_0
    [INFO     ][2s.812]: logging_thread_4_1
    [INFO     ][2s.812]: logging_thread_5_1
    [INFO     ][2s.812]: logging_thread_6_1
    ```

    - 10 потоков одновременно пишут логи
    - Тестирует циклический буфер под нагрузкой
    - Поток логирования имеет нормальный приоритет
    - Тестовые потоки блокируются при заполнении буфера

    > 💡 **Особенность:** Библиотека использует отложенный вывод логов через UART. При малом количестве логов они выводятся в фоновом режиме. При переполнении буфера потоки блокируются до освобождения места. Режимы `LOG_FATAL` и `LOG_ISR` обеспечивают мгновенный вывод.

### Верификация вывода

Корректность проверяется скриптом [`verify_output.py`](https://github.com/AleksandrVin/logging_cmsis_rtos2/blob/main/test/verify_output.py). Qemu создает виртуальный терминал, в который эмулируемая stm32 выводит данные. Скрипт на питоне подключается к этому терминалу и проверяет корректность вывода.

```python
# Пример проверки формата INFO сообщения
pattern = r"\[INFO\s*\]\[(\d+)s\.(\d+)\]: basic_test_(\d+)"
match = re.match(pattern, output)
if match:
    seconds = int(match.group(1))
    milliseconds = int(match.group(2))
    test_number = int(match.group(3))
```

Скрипт завершается успешно, если все сообщения корректны.
Данную часть нужно дорабатывать в зависимости от требований тестируемого проекта. Например, в данном случае, при зависании проекта или отсутвии полного набора сообщений, скрипт будет ожидать бесконечно. Это можно исправить, добавив таймауты и более сложное поведение, где при попадании в обработчких HardFault или подобное, будет вызван внутренний механизм "выключения" qemu.

## Автоматическое тестирование

После реализации тестовых сценариев следующим шагом является автоматизация их выполнения. Для этого используется комбинация Docker и GitHub Actions.

### Docker контейнеризация

Тестирование выполняется в тех же трех контейнерах, что были описаны ранее:

```yaml
services:
  tests:
    build:
      context: .
      dockerfile: Dockerfile.tests
    image: tests
  
  qemu_stm32:
    build:
      context: .
      dockerfile: Dockerfile.qemu_stm32
    depends_on:
      - tests
    image: qemu_stm32

  run_tests:
    build:
      context: .
      dockerfile: Dockerfile.run_tests
    depends_on:
      - qemu_stm32
      - tests
    volumes:
      - ./logs/:/test/logs
      - ./elf/:/elf
    profiles:
      - test
```

Каждый контейнер выполняет свою роль в процессе тестирования:

1. `tests` компилирует прошивку с тестами
2. `qemu_stm32` предоставляет среду эмуляции
3. `run_tests` запускает тесты и верифицирует результаты

### Запуск тестов

Автоматизация запуска реализована через скрипт `test.sh`:

```shell
#!/bin/bash
# Копирование библиотеки в тестовый проект
cp -r ../lib/ tests_stm32/logging_cmsis_rtos2

# Запуск контейнеров
docker compose --profile test up --build

# Сохранение логов
docker compose logs $container > $logs_file

# Получение кода завершения
exit_code=$(docker inspect -f '{{.State.ExitCode}}' $test_container_name)
```

> 💡 **Особенность:** Скрипт не только запускает тесты, но и обеспечивает корректное копирование библиотеки и сохранение результатов тестирования.

#### Интеграция с CI/CD

Тесты автоматически запускаются при каждом push и pull request через GitHub Actions:

```yaml:.github/workflows/test.yml
name: CI
on: 
    push:
    pull_request:

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - name: Run test
      run: cd test && ./test.sh
    - name: Archive test results
      uses: actions/upload-artifact@v4
      with:
        name: combined_logs
        path: |
          ./test/logs/logs.txt
          ./test/logs/serial_output.txt
```

> 💡 **Совет:** Для корпоративного использования можно настроить self-hosted runner на собственном сервере сборки. Подход совместим с GitLab CI и другими CI системами. В данном случае, используется GitHub Actions, который предоставляется бесплатно для open-source проектов.

### Анализ результатов

Тесты генерируют два файла с результатами:

1. `logs.txt` - отладочный вывод процесса тестирования
2. `serial_output.txt` - логи от тестируемой библиотеки

Эти файлы сохраняются как артефакты сборки и могут быть использованы для:

- Анализа причин падения тестов
- Проверки корректности работы библиотеки
- Документирования поведения системы

[следующий раздел о том, как отлаживать приложение в эмуляторе...]
