Зачем
Отладка встраиваемого оборудования с микроконтроллерами при помощи UART или Virtual COM Port в конфигурации с операционными системами реального времени, такими как FreeRTOS, часто затруднена. При старте прошивки, когда выполняется конфигурация периферии, создание потоков, примитивов синхронизации и выделение памяти, допускается большое количество ошибок, и узнать, что пошло не так без детальной внутрисхемной отладки сложно. В практике, логирование процесса инициализации может упростить работу. При каждом запуске полученный список событий и время возникновения указывает на место, где произошел сбой. Также возможно мониторить значения переменных, так как иногда мы сталкиваемся не только с ошибками в коде, но и багами из-за ошибок внутри кристалла. В таких случаях обращаются к errata sheet, однако это происходит не сразу.

Virtual COM Port — это популярный интерфейс, использующий USB для эмулирования UART, что удобно как во время отладки, так и в готовых устройствах. Минус этого интерфейса — отсутствие передачи сообщений сразу после инициализации. Данные пропадают, если новый вызов функции произошел быстрее, чем аппаратура успела передать содержимое прошлого буфера. Из-за этих особенностей события, произошедшие в первые секунды работы микроконтроллера, пропадают или повреждаются.

Библиотека логирования

Моя библиотека решает эту проблему. Система логирования, похожая на Python logging, благодаря которой возможно использовать LOG(log_level, format, ...), и сообщения будут доставлены устройству-потребителю. Исполнение программы будет заморожено до тех пор, пока клиентское приложение не считает данные из соответствующего файла, созданного драйвером Virtual COM Port.

Для этих целей библиотека создает дополнительный поток (thread) FreeRTOS с минимальным приоритетом, в котором при наличии логов в кольцевом буфере происходит их передача и ожидание флага драйвера, что сообщение было передано потребителю. Пользовательский поток, вызывая функцию логирования, добавляет сообщение в буфер с указанием времени возникновения. Таким образом, сам процесс логирования не вносит существенной задержки, как это было бы в случае прямого использования функций периферии. В случае, если буфер полон, функция логирования будет блокирующей до тех пор, пока место в буфере не появится. Это полезно, ведь подключение к ПК может произойти не сразу, но сообщения будут получены приложением ПК в правильном порядке и полном объеме.

Благодаря использованию отдельного потока для логирования мы можем использовать базовую функцию логирования где угодно, кроме прерываний. Ниже приведен пример добавления логирования в каркас функции потока FreeRTOS, сгенерированный STM32CubeMX

/* USER CODE END Header_StartDefaultTask */
void StartDefaultTask(void *argument)
{
  /* init code for USB_DEVICE */
  MX_USB_DEVICE_Init();
  /* USER CODE BEGIN StartDefaultTask */
  logging_init();
  LOG(DEBUG_ALL, "Logging inited");
  /* Infinite loop */
  for (;;)
  {
    osDelay(DEFAULT_TASK_DELAY);
    // blink Green LED
    HAL_GPIO_TogglePin(LD1_GPIO_Port, LD1_Pin);

    LOG(INFO, "I'm alive every 5 seconds from default task");
  }
  /* USER CODE END StartDefaultTask */
}
Если подключиться к терминалу, то мы увидим наши сообщения начиная с первого. Здесь видно время работы микроконтроллера, уровень события и сообщение. Библиотека сама настроит поток FreeRTOS, примитивы синхронизации и таймер для отсчета времени. Функция логирования безопасна для использования в многопоточных приложениях.

[DEBUG_ALL][0s.922]: Logging inited
[INFO     ][5s.922]: I'm alive every 5 seconds from default task
[INFO     ][10s.922]: I'm alive every 5 seconds from default task
[INFO     ][15s.922]: I'm alive every 5 seconds from default task
Настройка и начало работы
Для работы с библиотекой требуется добавить исходные файлы в проект или подключить как git submodule. Настраивается редактированием .h файлов.

Выбор интерфейса

Первое, что требуется, это выбрать интерфейс. Это может быть UART, USB-CDC (Virtual COM Port) или пользовательский интерфейс.Предварительно необходимо активировать и настроить блок периферии вручную или через STM32CubeMX. Давайте рассмотрим простейший случай, когда используется UART.

//logging.h:39
#define UART_INTERFACE huart1
Уровень логирования

Далее выбрать уровень логирования. При отладке рекомендуется DEBUG_ALL или DEBUG_MIN, тогда как в релизе рекомендуется переключить на ERR или NONE, тем самым отключив эти лишние сообщения.

typedef enum log_levels
{
    DEBUG_ALL = 0,
    DEBUG_MIN,
    INFO,
    WARNING,
    ERR,
    NONE
} log_levels_t;

// switch logging level. Only level above or equal to this will be printed
#ifndef LOGGING_LEVEL
#define LOGGING_LEVEL DEBUG_ALL
#endif
Uptime

По умолчанию, время(uptime) берется из таймера, который используется в FreeRTOS. Для увеличения производительности, особенно на микроконтроллерах без FPU, рекомендуется использовать дополнительные таймеры.

// better to replace this with custom timer implementation for better performance
#define UPTIME_MS (osKernelGetTickCount() * 1000 / osKernelGetTickFreq()) % 1000
#define UPTIME_S osKernelGetTickCount() / osKernelGetTickFreq()
Буферы
Максимальная длина сообщения ограничена размером буфера. Если у микроконтроллера малый объем памяти, рекомендуется уменьшить размеры буферов под ваши задачи. Количество сообщений в буфере также можно редактировать. Размер буфера считается только для полезной нагрузки. Для передачи временной метки и уровня буфер интерфейса будет увеличен на 20.

#define LOG_BUFFER_SIZE 100
#define LOG_QUEUE_ROWS 5
#define INTERFACE_BUFFER_SIZE (LOG_BUFFER_SIZE + 20)
