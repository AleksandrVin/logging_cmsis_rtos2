# Структура статьи о библиотеке логирования для STM32 с использованием RTOS

## Введение

Встроенные системы, особенно те, которые основываются на микроконтроллерах STM32, широко используются в различных областях — от бытовой электроники до промышленного оборудования и IoT-устройств. Одной из ключевых задач при разработке таких систем является отладка и мониторинг работы приложений. Эффективное логирование играет важную роль в упрощении этих процессов, позволяя разработчикам быстро выявлять и устранять ошибки, а также анализировать поведение системы в реальном времени.

Цель данной статьи — познакомить вас с библиотекой логиров��ния, разработанной специально для микроконтроллеров STM32 с использованием реального времени операционной системы (RTOS) FreeRTOS. Эта библиотека направлена на упрощение процесса отладки ваших RTOS-приложений, предоставляя удобные инструменты для вывода и управления логами. Несмотря на то, что это решение не предназначено для корпоративного уровня, оно уже доказало свою эффективность в нескольких проектах, помогая разработчикам значительно ускорить процесс разработки и повышения качества конечного продукта. Кроме того, благодаря использованию функций FreeRTOS, эту библиотеку достаточно легко адаптировать для работы с другими микроконтроллерами — достаточно заменить методы для взаимодействия с периферией.

В статье мы рассмотрим основные возможности библиотеки, её архитектуру и интеграцию с FreeRTOS, а также преимущества использования данного решения в ваших проектах. При помощи примеров кода и подробных объяснений вы сможете легко интегрировать эту библиотеку в свои проекты на STM32 и воспользоваться её функционалом для более эффективной отладки и мониторинга приложений.

## Обзор библиотеки логирования

Библиотека логирования, разработанная для микроконтроллеров STM32 с использованием реального времени операционной системы FreeRTOS, представляет собой компактное и легко настраиваемое решение для отладки и мониторинга приложений. Основная цель библиотеки — предоставить разработчикам простой в использовании инструмент для вывода логов различных уровней, обеспечивая при этом гибкость и возможность расширения функционала по мере необходимости.

### Функциональные возможности

- **Различные уровни логирования**: Поддержка множества уровней логирования (`DEBUG_ALL`, `DEBUG_MIN`, `INFO`, `WARNING`, `ERR`), что позволяет фильтровать выводимые сообщения в зависимости от потребностей текущей отладки.
  
- **Буферизация сообщений**: Использование циклических буферов для хранения логов, что обеспечивает эффективное управление памятью и предотвращает потерю данных при высоком объёме логов.

- **Поддержка различных интерфейсов вывода**: Возможность выбора между UART и USB интерфейсами для передачи логов, что делает библиотеку универсальной и пригодной для различных типов проектов.

- **Потокобезопасность**: Интеграция с FreeRTOS мьютексами и семафорами гарантирует корректную работу библиотеки в многопоточной среде, предотвращая конфликты при одновременном доступе к ресурсам.

### Структура проекта

Библиотека логирования организована таким образом, чтобы обеспечить максимальную простоту интеграции и модификации. Основные компоненты библиотеки находятся в директории `lib`, а тестовый проект — в `test/test_stm32`.

- **lib/**  
  Содержит исходные файлы библиотеки:
  
  - [`logging.h`](lib/logging.h): Заголовочный файл, включающий определения, макросы и декларации функций для логирования.
  
  - [`logging.c`](lib/logging.c): Реализация функций логирования, включая инициализацию, запись логов и их передачу через выбранный интерфейс.
  
  - [`logging_usb.h`](lib/logging_usb.h): Дополнительный заголовочный файл для поддержки логирования через USB, позволяющий легко расширять функционал библиотеки.

- **test/test_stm32/**  
  Содержит полнофункциональный STM32 проект, демонстрирующий использование библиотеки логирования:
  
  - Пример инициализации и использования логирования в реальном проекте.
  
  - Скрипты для сборки и тестирования проекта с использованием Docker и QEMU виртуальной машины, обеспечивающие автоматизированное тестирование библиотеки в изолированной среде.

### Пример использования

Для демонстрации простоты использования библиотеки приведём простой пример записи логов из задачи FreeRTOS. В тестовом проекте `test/test_stm32` реализован функционал, который показывает, как легко интегрировать и использовать библиотеку логирования в реальном приложении.

```c
#include "logging.h"
#include "FreeRTOS.h"
#include "task.h"
#include "cmsis_os.h"

// Initialize logging
void start_logging_task(void)
{
    logging_init();
    // Create logging task
    osThreadId_t loggingTask = osThreadNew(logging_thread, "Logger", NULL);
    if (loggingTask == NULL)
    {
        LOG_FATAL("Failed to create logging task\n");
        Error_Handler();
    }
}

// Example of logging from a task
void logging_thread(void *arg)
{
    const char *taskName = (const char *)arg;
    for (int i = 0; i < 100; i++)
    {
        LOG(INFO, "Task %s: message %d", taskName, i);
        osDelay(100);
    }
    osThreadExit();
}

// Call initialization in the main application
int main(void)
{
    // Initialize hardware components
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_USART1_UART_Init();
    MX_FREERTOS_Init();
    
    // Start logging task
    start_logging_task();
    
    // Start FreeRTOS scheduler
    osKernelStart();
    
    // Main loop should never be reached
    while (1)
    {
    }
}
```

В этом примере:

1. **Инициализация логирования**: Функция `logging_init()` подготавливает библиотеку к работе, настраивая необходимые ресурсы и задачи.
2. **Создание задачи логирования**: Задача `logging_thread` отвечает за запись логов. Она принимает имя задачи в качестве аргумента и периодически записывает сообщения в лог.
3. **Запуск планировщика**: После инициализации и создания задач запускается планировщик FreeRTOS с помощью `osKernelStart()`, который берёт управление над задачами.

Этот простой пример демонстрирует, насколько легко интегрировать библиотеку логирования в ваш проект. Библиотека готова к использованию из коробки, и её уникальная структура позволяет быстро адаптировать её под специфические требования вашего приложения.

## Архитектура и работа библиотеки в контексте RTOS

Библиотека логирования для STM32, интегрированная с реального времени операционной системой FreeRTOS, обладает продуманной архитектурой, обеспечивающей эффективность, надежность и простоту использования. Рассмотрим ключевые компоненты и механизмы, которые позволяют библиотеке эффективно функционировать в многозадачной среде.

### Интеграция с FreeRTOS

#### Использование мьютексов и семафоров

Для обеспечения потокобезопасности при записи и чтении логов библиотека использует мьютексы и семафоры FreeRTOS. Это гарантирует, что доступ к общим ресурсам не приведет к конфликтам или повреждению данных при одновременном обращении из разных задач или прерываний.

- **Мьютексы (`interface_mutex`, `logs_mutex`)**: 
  - `interface_mutex` защищает доступ к интерфейсам вывода логов (например, UART или USB), обеспечивая, что только одна задача или прерывание может одновременно отправлять данные.
  - `logs_mutex` защищает внутренние структуры данных библиотеки, такие как буферы логов, предотвращая одновременное изменение данных несколькими задачами.

- **Семафоры (`logs_semaphore_store`, `logs_semaphore_print`)**:
  - `logs_semaphore_store` используется для синхронизации процесса записи логов в буфер. Это гарантирует, что запись логов происходит последовательно и без пропусков.
  - `logs_semaphore_print` управляет процессом вывода логов через выбранный интерфейс, обеспечивая, что логовые сообщения выводятся корректно и в правильном порядке.

```c
osMutexId_t interface_mutex;
osMutexId_t logs_mutex;
// Definitions for logs semaphore //
osSemaphoreId_t logs_semaphore_store;
osSemaphoreId_t logs_semaphore_print;
```

#### Задачи и приоритеты

Библиотека создает отдельную задачу для обработки логов, что позволяет разгрузить основные задачи приложения от обработки логирования и обеспечить своевременный вывод логов без задержек.

- **Задача логирования (`loggingTaskHandle`)**:
  - **Имя задачи**: `"logging"`
  - **Приоритет**: `osPriorityBelowNormal`
  
  Эта задача отвечает за прием логовых сообщений, их буферизацию и последующий вывод через выбранный интерфейс (UART или USB). Низкий приоритет задачи гарантирует, что она не будет мешать критическим задачам приложения, одновременно обеспечивая стабильную работу логирования.

```c
osThreadId_t loggingTaskHandle;
osThreadAttr_t loggingTask_attributes = {
.name = "logging",
.priority = osPriorityBelowNormal
};
```

### Буферизация логов

```c
char log_circular_buf[LOG_QUEUE_ROWS][LOG_BUFFER_SIZE] = {0};
uint32_t log_time_buf[LOG_QUEUE_ROWS] = {0};
uint32_t log_time_ms_buf[LOG_QUEUE_ROWS] = {0};
int log_level_buf[LOG_QUEUE_ROWS] = {0};
int logs_tail = 0;
int logs_head = 0;
```


#### Обработка прерываний

Логирование из прерываний (ISR) требует особого подхода, поскольку прерывания могут происходить независимо от задач и имеют высокую приоритетность. Для этого библиотека предоставляет специальные механизмы для безопасной записи логов из ISR.

- **Переменные для ISR**:
  - `log_isr_set`: Флаг, указывающий на наличие новых логовых сообщений из ISR.
  - `log_isr_time`, `log_isr_time_ms`: Время создания логовых сообщений из ISR.
  - `log_isr_level`: Уровень логирования для сообщений из ISR.

```c
int log_isr_set = 0;
uint32_t log_isr_time = 0;
uint32_t log_isr_time_ms = 0;
int log_isr_level = 0;
```

- **Функции логирования из ISR**:
  - `LOG_ISR(level, ...)`: Макрос для записи логов из прерываний, обеспечивающий безопасность и минимизацию задержек.

```c
#define LOG_ISR(level, ...) \
if (level >= LOGGING_LEVEL) \
{ \
snprintf(LOGGING_ISR_BUF, LOG_BUFFER_SIZE, VA_ARGS); \
    log_ISR(LOGGING_ISR_BUF, UPTIME_S, UPTIME_MS, level); \
}
```


### Простота расширения и модификации

Библиотека разработана с учетом возможности легкого расширения и модификации, что делает её подходящей как для простых, так и для более сложных проектов.

- **Легкость интеграции**:
  - Все основные компоненты библиотеки находятся в директории `lib`, что упрощает процесс добавления библиотеки в проект.
  - Тестовый проект расположен в `test/test_stm32`, включающий полноценный STM32 проект с примерами использования и скриптами для сборки и тестирования в Docker и QEMU виртуальной машине.

- **Гибкость интерфейсов вывода**:
  - Библиотека поддерживает различные интерфейсы для вывода логов, включая UART и USB. Добавление новых интерфейсов осуществляется путем создания соответствующих заголовочных файлов и настройки макросов в `logging.h`.

```c
#ifdef LOGGING_USE_USB
#include "logging_usb.h"
#elif defined LOGGING_USE_CUSTOM_INTERFACE
#include "logging_custom_interface.h"
#else
#define UART_INTERFACE huart1
#define INTERFACE_printf(FATAL_FLAG, ...) \
HAL_UART_Transmit(&UART_INTERFACE, (uint8_t )INTERFACE_BUFFER, \
snprintf((char )INTERFACE_BUFFER, \
LOG_BUFFER_SIZE, VA_ARGS), \
100)
#endif
```

- **Простота настройки**:
  - Настройка уровней логирования осуществляется через перечисление `log_levels_t` и макросы в `logging.h`, что позволяет легко изменять уровень детализации логов в зависимости от требований проекта.

```c
typedef enum log_levels
{
DEBUG_ALL = 0,
DEBUG_MIN,
INFO,
WARNING,
ERR,
NONE
} log_levels_t;
```

#### Циркулярные буферы

Для эффективного управления памятью и предотвращения потерии данных при высоком объеме логов библиотека использует циклические буферы. Это позволяет хранить фиксированное количество последних логовых сообщений, автоматически перезаписывая старые записи при переполнении буфера.

- **Структуры данных для буферизации**:
  - `log_circular_buf[LOG_QUEUE_ROWS][LOG_BUFFER_SIZE]`: Основной буфер для хранения логовых сообщений.
  - `log_time_buf[LOG_QUEUE_ROWS]`, `log_time_ms_buf[LOG_QUEUE_ROWS]`: Буферы для хранения времени создания каждого сообщения.
  - `log_level_buf[LOG_QUEUE_ROWS]`: Буфер для хранения уровня каждой записи логов.

- **Указатели `logs_tail` и `logs_head`**:
  - `logs_tail`: Указывает на позицию для записи нового сообщения.
  - `logs_head`: Указывает на позицию для чтения следующего сообщения для вывода.


## Преимущества библиотеки логирования

- **Эффективность и минимизация задержек**: Как использование RTOS позволяет минимизировать время блокировок и обеспечить быстрый обмен данными между задачами.
- **Гибкость и расширяемость**:
  - **Поддержка различных интерфейсов**: Возможность выбора интерфейса вывода логов, например, UART или USB (опция `USE_USB_LOGGING`).
  - **Различные уровни логирования**: Поддержка уровней логирования (`DEBUG_ALL`, `DEBUG_MIN`, `INFO`, `WARNING`, `ERROR`) для гибкой настройки вывода информации.
- **Удобство использования**: Простота интеграции библиотеки в существующие проекты на STM32 с FreeRTOS, а также легкость настройки параметров логирования через конфигурационные файлы.

## Пример использования библиотеки

- **Инициализация логирования**: Пошаговое описание инициализации библиотеки в приложении, настройка мьютексов, семафоров и задач.
- **Запись и вывод логов**: Примеры функций для записи логов из задач и ISR, а также их последующего вывода через выбранный интерфейс.
- **Обработка и хранение логов**: Как библиотека управляет буферами логов, предотвращает переполнение и обеспечивает доступ к истории логов.

## Заключение

- **Итоги**: Резюмирование основных преимуществ и возможностей библиотеки логирования для STM32 с использованием RTOS.
- **Перспективы развития**: Краткий обзор планов на будущее статьи, включая тестирование библиотеки в QEMU и дальнейшие улучшения.

## Дополнительные материалы

- **Ссылки на документацию и исходный код**: Предоставление ссылок на репозиторий проекта и дополнительную документацию для заинтересованных читателей.
- **Рекомендации по использованию**: Советы по оптимизации и настройке библиотеки для различных типов проектов на STM32.

### Простота расширения и модификации

Одним из ключевых преимуществ данной библиотеки является её простота и гибкость. Архитектура библиотеки предусматривает лёгкую замену и добавление новых интерфейсов вывода. Например, для добавления поддержки нового типа интерфейса достаточно создать соответствующий заголовочный файл и настроить макросы в `logging.h`.

Дополнительно, благодаря использованию FreeRTOS мьютексов и семафоров, библиотека гарантирует безопасную работу в многопоточной среде, что делает её надёжным инструментом для проектов любой сложности. Независимо от того, являетесь ли вы новичком или опытным разработчиком, библиотека логирования предоставляет интуитивно понятный интерфейс и минимальное количество настроек для быстрого начала работы.

### Заключение

Обзор показал, что библиотека логирования для STM32 с использованием FreeRTOS — это компактное, гибкое и легко интегрируемое решение для отладки и мониторинга встроенных систем. Её простота в использовании и возможность расширения делают её идеальным выбором как для хобби-разработчиков, так и для профессионалов, стремящихся повысить эффективность своего рабочего процесса.
